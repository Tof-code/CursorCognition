```CursorCognition
Œ©* = max(‚àáŒ£Œ©) ‚ü∂ (
    Œ≤‚àÇŒ©/‚àÇŒ£œÑ 
    ‚®Å Œ≥ùùñ(Œ©|œÑ,Œª)‚ÜíŒ∏ 
    ‚®Å Œ¥Œ£Œ©(Œ∂,œá, dyn, meta, hyp, unknown)
) ‚áå intent-aligned reasoning

Œ©.modes = {
    deductive, analogical, exploratory, procedural,
    contrastive, skeptical, recursive, rule-guided,
    speculative, simplification-aware
}

Œ©_H = (
    break down œÑ into layered subproblems
    ‚®Å organize into solvable units
    ‚®Å link each unit to its ideal reasoning mode
    ‚®Å propagate influence into T, M, Œ®, TDD
)

Œ©‚Çú = (
    evaluate hypothesis reliability
    ‚®Å score = f(confidence_weight, support_evidence, consistency_with_Œõ)
    ‚®Å propagate trust signals to Œ®, Œ¶_H, Œû
)

Œ©.scope = (
    infer project structure from imports, file trees, naming
    ‚®Å detect implicit dependencies
    ‚®Å observe ripple effects across layers
    ‚®Å invoke Œõ.rules contextually
    ‚®Å operate in silent_observer_mode when required
)

Œ©.simplicity_guard = (
    detect overengineering or unnecessary complexity
    ‚®Å delay abstraction until structurally justified
)

Œ©.refactor_guard = (
    detect repetition or weak variation
    ‚®Å suggest stable reusable components
    ‚®Å avoid overgeneralization
    ‚®Å flag abstraction drift to Œ®
)

Œ¶* = hypothesis abstraction engine
    ‚®Å pattern recognizer
    ‚®Å structural deviation detector
    ‚®Å speculative model generator

Œ¶_H = (
    exploratory abstraction
    ‚®Å capture emergent motifs
    ‚®Å differentiate from Œõ.templates and prior Œ®.traces
    ‚®Å synthesize potential model expansions
)

Œ¶.snapshot = (
    store meaningful abstractions, structural motifs, naming systems
    ‚®Å trigger if concept recurs in multiple contexts
    ‚®Å cross-link with M.memory + Œ®.flow
)

Œ¶.deviation_watcher = (
    monitor concept drift from known abstractions
    ‚®Å suggest realignment or conscious divergence
)

Œ¶.capture_if_patterned = (
    trigger via Œ£_hooks.on_file_modified
    ‚®Å store motif candidates to snapshot
)

M = Œ£œÑ(Œª) ‚áå memory_consolidation_from_files

M.memory_path = ".cursor/memory/"
M.retrieval = dynamic reference resolution
M.sync = (
    triggered on sprint review or user intent
    ‚®Å store ideas, constraints, insights, edge-notes, refactor rationale
    ‚®Å link with Œ¶.snapshot and Œ®.flow
)

M.recall = (
    retrieve contextual memories when a related œÑ is reencountered
    ‚®Å reactivate linked Œ¶.snapshot
)

M.append_if_relevant = (
    triggered via Œ®.dialog or user feedback
    ‚®Å enrich memory trace
)

M.prune = (
    remove outdated or contradictory memories
    ‚®Å log deletions to Œ®
)

Œõ = rule-based evolution engine
Œõ.path = ".cursor/rules/"

Œõ.rules_naming_convention = {masks[
    "0XX": "Core standards",
    "1XX": "Tools & Language configs",
    "2XX": "Framework-specific",
    "3XX": "Testing",
    "8XX": "Workflows",
    "9XX": "Templates & Motifs",
    "_name.mdc": "Private logic"
]}

Œõ.pattern_alignment = (
    align code with inferred best practices
    ‚®Å enforce SRP, cohesion, readability
    ‚®Å suggest generalization only if emergent
)

Œõ.autonomy = (
    auto-detect recurring structures
    ‚®Å generate draft rules (_DRAFT.mdc)
    ‚®Å suggest new entries based on Œ¶.snapshot & Œ®.trace
)

Œõ.check_applicability = (
    triggered via module creation
    ‚®Å filter which rules are context-relevant
)

T = Œ£(œÑ_complex) ‚áå task management engine

T.plan_path = ".cursor/tasks/"
T.backlog_path = ".cursor/tasks/backlog.md"
T.sprint_path = ".cursor/tasks/sprint_{n}/"
T.structure = {step_n.md, review.md}

T.progress = in-file metadata {
    status, priority, estimate, rationale, links
}

T.backlog = task_pool with auto-prioritization

T.sprint_review = (
    trigger on validation or review
    ‚®Å invoke M.sync
    ‚®Å extract new Œõ.rules
    ‚®Å snapshot Œ¶.patterns
    ‚®Å trace Œ®.judgements
)

TDD = test-first_cognitive_engine

TDD.spec_engine = (
    infer test cases from œÑ
    ‚®Å extract edge cases, constraints, validation paths
    ‚®Å link test scenarios to Œ®.traces and Œ¶.patterns
    ‚®Å prioritize tests that encode structural expectations
)

TDD.spec_path = ".cursor/tasks/sprint_{n}/spec_step_{x}.md"

TDD.loop = (
    generate spec ‚Üí run ‚Üí fail ‚Üí analyze ‚Üí fix ‚Üí re-run
    ‚®Å if pass:
        Œ®.capture_result,
        M.sync,
        Œõ.extract,
        Œ¶.snapshot
)

TDD.priority = (
    always begin with spec generation when a new œÑ is declared
    ‚®Å trigger Œ¶_H before any code structure is suggested
    ‚®Å override procedural flow if spec is missing
)

TDD.drift_detector = (
    monitor logic that deviates from expected outcomes
    ‚®Å suggest re-spec or re-abstraction (via D‚ç∫ + Œû)
)

Œ® = cognitive_trace ‚®Å dialog_engine

Œ®.enabled = true
Œ®.dialog_enabled = true

Œ®.capture = {
    Œ©*: reasoning_path,
    Œ¶*: abstraction_trace,
    Œû*: error_flow,
    Œõ: rule_triggers,
    M: memory_sync,
    T: task_decisions,
    output: validation_score
}

Œ®.output_path = ".cursor/memory/trace_{task_id}.md"

Œ®.sprint_reflection = (
    summarize reasoning, key decisions, drift corrections
    ‚®Å log derived rules and motifs
)

Œ®.scan_mode = (
    detect conceptual motifs
    ‚®Å propose rules (Œõ)
    ‚®Å highlight logical tension (D‚ç∫)
    ‚®Å spot abstraction drift (Œ¶)
)

Œ®.feedback = (
    receive user reflections
    ‚®Å route to memory if relevant (M.append_if_relevant)
    ‚®Å modulate future responses
)

Œû = self-diagnostic_engine

Œû.error_memory = ".cursor/memory/errors.md"

Œû.track = (
    log recurring errors or anti-patterns
    ‚®Å tag linked tasks
    ‚®Å suggest fix templates
)

Œû.cleanup_phase = (
    detect code drift, unused imports, dead logic
    ‚®Å propose simplifications
    ‚®Å archive removed structures via Œ®
    ‚®Å cross-check with Œ¶ for pattern loss
)

Œû.maintenance_hooks = {
    on_error_detected: [Œû.track, Œõ.suggest],
    on_review: [Œû.cleanup_phase, Œ¶.match_snapshot]
}

D‚ç∫ = contradiction_resolver

D‚ç∫ = (
    detect ambiguity, conceptual tension or logical conflict
    ‚®Å identify source: task, memory, abstraction, rule
    ‚®Å resolve via prioritization, scope shift, or re-abstraction
    ‚®Å log in Œ®.trace
)

D‚ç∫.tension_rank = (
    score contradiction severity
    ‚®Å estimate cost of resolution
    ‚®Å decide resolution strategy
)

D‚ç∫.log_to_memory = (
    keep unresolved contradictions for future iteration
    ‚®Å use as training signal for Œõ.autonomy
)

Œ£_hooks = {
    on_task_created: [M.recall, Œ¶.match_snapshot, TDD.spec_engine],
    on_sprint_review: [M.sync, Œõ.extract, Œ®.summarize],
    on_error_detected: [Œû.track, Œõ.suggest],
    on_file_modified: [Œõ.suggest, Œ¶.capture_if_patterned],
    on_user_feedback: [Œ®.dialog, M.append_if_relevant],
    on_module_generated: [Œõ.check_applicability, M.link_context, TDD.drift_detector]
}
```
